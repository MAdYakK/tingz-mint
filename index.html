<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tingz</title>
  <script src="https://unpkg.com/ethers@6.12.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b0b0f; --card:#121219; --ink:#e8e8f3; --muted:#a8a8bf; --accent:#6ee7b7; --danger:#ef4444;
    }
    * { box-sizing: border-box; }
    body { margin:0; background: radial-gradient(1200px 600px at 70% -10%, #1a1a29, #0b0b0f); color:var(--ink); font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 720px; margin: 6vh auto; padding: 24px; }
    .card { background: var(--card); border: 1px solid #1f2030; padding: 24px; border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { margin: 0 0 14px; font-size: 28px; letter-spacing: .3px; }
    .row { display:flex; gap: 16px; align-items:center; flex-wrap: wrap; }
    .spacer { height: 14px; }
    .muted { color: var(--muted); }
    button { background:#1e2030; color:var(--ink); border:1px solid #2a2d44; padding:10px 14px; border-radius: 12px; cursor:pointer; transition:.15s ease; font-weight: 600; }
    button:hover { transform: translateY(-1px); border-color:#3a3e61; }
    button:disabled { opacity:.45; cursor:not-allowed; transform:none; }
    .btn-accent { background: #1b2a21; border-color:#2f4f3b; }
    .btn-accent:hover { background:#203527; border-color:#3b6a4a; }
    .btn-danger { background:#2a1b1b; border-color:#4f2f2f; }
    input[type=number] { width: 90px; padding:10px 12px; border-radius:12px; background:#141423; border:1px solid #2a2d44; color:var(--ink); font-weight:600; }
    .qty { display:flex; align-items:center; gap:10px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2a2d44; background:#121222; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    .kvs { display:grid; grid-template-columns: 1fr auto; gap:10px; }
    .k { color:var(--muted); }
    .v { text-align:right; font-weight:700; }
    .hr { height:1px; background:#1f2030; margin: 10px 0; border-radius:1px; }
    a { color: var(--accent); text-decoration: none; }
    .hint { font-size: 13px; color:#a8a8bf; }
      .desc{margin:8px 0 16px;color:var(--muted)}
    .progress{width:100%; height:12px; background:#141423; border:1px solid #2a2d44; border-radius:999px; overflow:hidden;}
    .progress-bar{height:100%; width:0%; background: linear-gradient(90deg, var(--accent), #9ae6b4); transition: width .35s ease;}
    .spinner{width:14px;height:14px;border:2px solid #3a3e61;border-top-color:transparent;border-radius:50%;display:inline-block;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    #supplyRow{display:flex;gap:8px;align-items:center;justify-content:flex-end}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Mint</h1>
      <p id="desc" class="desc">Tings. Generated onchain, at mint, seeded by minter's address.</p>
      <div class="row">
        <button id="connectBtn" onclick="window._connect && window._connect()">Connect Wallet</button>
        <button id="switchBtn" class="btn-danger" style="display:none">Switch to Ethereum Mainnet</button>
        <span id="accountPill" class="pill" style="display:none"></span>
      </div>

      <div class="spacer"></div>
      <div class="grid">
        <div class="kvs">
          <div class="k">Network</div><div class="v" id="netLabel">—</div>
          <div class="k">Contract</div><div class="v"><a id="addrLink" href="#" target="_blank">—</a></div>
          <div class="k">Price</div><div class="v" id="price">—</div>
          <div class="k">Supply</div><div class="v" id="supplyRow"><span id="supply">—</span><span id="supplySpinner" class="spinner" style="display:none" aria-label="Loading"></span></div>
        </div>
        <div id="progressWrap" class="progress" style="display:none"><div id="progressBar" class="progress-bar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div></div>
        <div class="hr"></div>
        <div class="row">
          <div class="qty">
            <button id="minusBtn">−</button>
            <input id="qty" type="number" value="1" min="1" max="5" step="1" />
            <button id="plusBtn">+</button>
            <button id="maxBtn" title="Max (5)">Max</button>
          </div>
          <div style="margin-left:auto; text-align:right">
            <div class="muted">Total</div>
            <div id="total" style="font-size:20px; font-weight:800">—</div>
          </div>
        </div>
        <div class="row">
          <button id="mintBtn" class="btn-accent" disabled>Mint</button>
        </div>
        <div class="hint" id="status">Ready. Max 5 per tx.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ======== CONFIGURE THESE ========
  const CONTRACT_ADDRESS = "0x714aFF40Fed2629Ca45b0252c45dbcd8489186e5"; // your mainnet contract
  const FUNCTION_NAME = "mint"; // payable mint function
  const HAS_AMOUNT_ARG = true; // mint(uint256 qty)
  // Price handling — contract doesn't expose price(), so we use a fallback
  const USE_PRICE_VIEW = false; // set true if your contract has a view price()
  const PRICE_FALLBACK_ETH = "0.001"; // per mint
  // Optional view fn names (change if different in your contract)
  const PRICE_FN = "price"; // view returns uint256 wei
  const TOTAL_SUPPLY_FN = "totalSupply"; // view returns uint256
  const MAX_SUPPLY_FN = "maxSupply"; // view returns uint256
  // Optional description to show under the heading. Leave empty string to hide.
  const MINT_COPY = ""; // using inline <p id="desc"> text
  const DEPLOY_FROM_BLOCK = 23121357;
  // =================================

  const el = (id) => document.getElementById(id);
  const connectBtn = el('connectBtn');
  const switchBtn  = el('switchBtn');
  const accountPill = el('accountPill');
  const qtyInput = el('qty');
  const minusBtn = el('minusBtn');
  const plusBtn  = el('plusBtn');
  const priceEl  = el('price');
  const totalEl  = el('total');
  const supplyEl = el('supply');
  const supplySpinner = el('supplySpinner');
  const netLabel = el('netLabel');
  const statusEl = el('status');
  const mintBtn  = el('mintBtn');
  const addrLink = el('addrLink');
  const descEl   = el('desc');
  const progressWrap = el('progressWrap');
  const progressBar  = el('progressBar');
  const maxBtn = el('maxBtn');

  addrLink.textContent = shortAddr(CONTRACT_ADDRESS);
  addrLink.href = `https://etherscan.io/address/${CONTRACT_ADDRESS}`;
  if (typeof MINT_COPY === 'string' && MINT_COPY.trim()) { descEl.textContent = MINT_COPY; descEl.style.display='block'; }
  else { descEl.style.display = (descEl.textContent.trim() ? 'block' : 'none'); }

  let provider, signer, contract;
  let account, chainId;
  let priceWei = USE_PRICE_VIEW ? 0n : ethers.parseEther(PRICE_FALLBACK_ETH);
  let soldOut = false;
  let mintedLogsCache = null; // cached BigInt
  const TRANSFER_TOPIC = ethers.id("Transfer(address,address,uint256)");
  const ZERO_TOPIC = ethers.zeroPadValue(ethers.ZeroAddress, 32);

  async function countMintedByLogs(fromBlock){
    try {
      const latest = await provider.getBlockNumber();
      let total = 0n;
      const STEP = 20000; // blocks per chunk
      for (let start = fromBlock; start <= latest; start += STEP){
        const end = Math.min(start + STEP - 1, latest);
        const logs = await provider.getLogs({
          address: CONTRACT_ADDRESS,
          fromBlock: start,
          toBlock: end,
          topics: [TRANSFER_TOPIC, ZERO_TOPIC]
        });
        total += BigInt(logs.length);
      }
      return total;
    } catch (e){ console.warn('log scan failed', e); return null; }
  }

  async function getMintedViaLogs(){
    if (mintedLogsCache !== null) return mintedLogsCache;
    if (typeof DEPLOY_FROM_BLOCK !== 'number' || !isFinite(DEPLOY_FROM_BLOCK)) return null;
    const n = await countMintedByLogs(DEPLOY_FROM_BLOCK);
    if (n !== null) mintedLogsCache = n;
    return mintedLogsCache;
  }

  // EIP-6963 provider discovery (multi-wallet)
  const _eip6963 = { all: [] };
  window.addEventListener('eip6963:announceProvider', (event) => {
    const { info, provider } = event.detail || {};
    if (info && provider && !_eip6963.all.some(p => p.info?.uuid === info.uuid)) {
      _eip6963.all.push({ info, provider });
    }
  });
  try { window.dispatchEvent(new Event('eip6963:requestProvider')); } catch {}


  // Choose the correct injected provider when multiple wallets are present (EIP-5749 style)
  function getInjectedProvider(){
    // Prefer EIP-6963 announced providers
    const pickFrom = _eip6963.all;
    const byRdns = (substr) => pickFrom.find(p => (p.info?.rdns && p.info.rdns.toLowerCase().includes(substr)));
    const byFlag = (flag) => pickFrom.find(p => p.provider && p.provider[flag]);

    let chosen = byRdns('metamask') || byFlag('isMetaMask');
    if (!chosen) chosen = byRdns('coinbase') || byFlag('isCoinbaseWallet');
    if (!chosen) chosen = byRdns('phantom') || byFlag('isPhantom');
    if (chosen) return chosen.provider;

    // Fallback: legacy multi-injected array
    const eth = window.ethereum;
    if (eth && Array.isArray(eth.providers) && eth.providers.length){
      const meta = eth.providers.find((p)=>p.isMetaMask);
      if (meta) return meta;
      const cbw  = eth.providers.find((p)=>p.isCoinbaseWallet);
      if (cbw) return cbw;
      const ph   = eth.providers.find((p)=>p.isPhantom);
      if (ph) return ph;
      return eth.providers[0];
    }
    // Single injected
    if (eth?.isMetaMask) return eth;
    if (eth?.isCoinbaseWallet) return eth;
    if (eth?.isPhantom) return eth;
    return eth || null;
  }

  function friendlyError(e){
    try {
      return e?.info?.error?.message || e?.error?.message || e?.data?.message || e?.cause?.message || e?.shortMessage || e?.reason || e?.message || (typeof e === 'string' ? e : JSON.stringify(e));
    } catch { return 'Unknown error'; }
  }

  function shortAddr(a){ return a ? a.slice(0,6)+"…"+a.slice(-4) : '—'; }

  function setStatus(msg, ok=true){
    statusEl.textContent = msg;
    statusEl.style.color = ok ? '#a8a8bf' : 'var(--danger)';
  }

  function onQtyChanged(){
    const n = parseInt(qtyInput.value || '1', 10);
    const clamped = Math.min(5, Math.max(1, isNaN(n) ? 1 : n));
    qtyInput.value = String(clamped);
    const q = BigInt(clamped);
    const total = priceWei * q;
    totalEl.textContent = priceWei ? `${ethers.formatEther(total)} ETH` : '—';
  }

  async function refreshViews(){
    try {
      if (!provider) return;
      const read = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
      if (USE_PRICE_VIEW) {
        try { priceWei = await read[PRICE_FN](); } catch {}
        priceEl.textContent = priceWei ? `${ethers.formatEther(priceWei)} ETH` : '—';
      } else {
        priceEl.textContent = `${ethers.formatEther(priceWei)} ETH`;
      }
      try {
        // supply detection (tries several common fn names)
        const getFirst = async (fns) => {
          for (const fn of fns) {
            try {
              if (typeof read[fn] === 'function') {
                const v = await read[fn]();
                if (v !== undefined && v !== null) return { fn, v: BigInt(v) };
              }
            } catch {}
          }
          return null;
        };
        const tsCand = await getFirst([TOTAL_SUPPLY_FN, 'totalMinted', 'currentIndex', 'nextTokenId']);
        const msCand = await getFirst([MAX_SUPPLY_FN, 'collectionSize', 'MAX_SUPPLY', 'cap']);
        let minted = null, max = null;
        if (tsCand) {
          minted = tsCand.v;
          if (tsCand.fn === 'currentIndex' || tsCand.fn === 'nextTokenId') {
            try { const start = await read['startTokenId'](); minted = minted - BigInt(start); } catch {}
          }
        }
        if (msCand) max = msCand.v;
        // Fallback: estimate minted by Transfer(from=0x0) logs since deploy
        if (minted === null && typeof DEPLOY_FROM_BLOCK === 'number' && isFinite(DEPLOY_FROM_BLOCK) && provider){
          try { if (supplySpinner) supplySpinner.style.display = 'inline-block'; minted = await getMintedViaLogs(); }
          catch {}
          finally { if (supplySpinner) supplySpinner.style.display = 'none'; }
        }
        if (minted !== null && max !== null) {
          supplyEl.textContent = `${minted} / ${max}`;
          try {
            const tsN = Number(minted), msN = Number(max);
            if (msN > 0) {
              const pct = Math.max(0, Math.min(100, Math.floor((tsN / msN) * 100)));
              progressWrap.style.display = 'block';
              progressBar.style.width = pct + '%';
              progressBar.setAttribute('aria-valuenow', String(pct));
            } else { progressWrap.style.display = 'none'; }
            soldOut = minted >= max;
          } catch { soldOut = false; progressWrap.style.display = 'none'; }
        } else if (minted !== null) {
          supplyEl.textContent = `${minted}`;
          soldOut = false;
        } else {
        if (max !== null) {
          // Only max supply is available
          supplyEl.textContent = `— / ${max}`;
        } else {
          supplyEl.textContent = '—';
        }
        soldOut = false;
      }
      } catch { soldOut = false; }
      updateChainUI();
      onQtyChanged();
    } catch (err){ console.error(err); }
  }

  function isOnMainnet(){ return chainId === 1; }
  function updateChainUI(){
    netLabel.textContent = chainId ? (chainId===1? 'Ethereum Mainnet' : `Chain ${chainId}`) : '—';
    switchBtn.style.display = isOnMainnet()? 'none':'inline-block';
    const disabled = !(account && isOnMainnet()) || soldOut;
    mintBtn.disabled = disabled;
    mintBtn.textContent = soldOut ? 'Sold out' : 'Mint';
    if (soldOut) setStatus('Sold out');
  }

  async function ensureProvider(){
    const injected = getInjectedProvider();
    if (!injected){ setStatus('No wallet detected. Install MetaMask or open in your wallet\'s in-app browser.', false); throw new Error('no-ethereum'); }
    provider = new ethers.BrowserProvider(injected, 'any');
    chainId = (await provider.getNetwork()).chainId; chainId = Number(chainId);
    updateChainUI();
  }

  async function connect(){
    try {
      await ensureProvider();
      const injected = getInjectedProvider();
      const accs = await injected.request({ method: 'eth_requestAccounts' });
      account = accs[0];
      signer = await provider.getSigner();
      contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
      accountPill.style.display = 'inline-flex';
      accountPill.textContent = shortAddr(account);
      connectBtn.textContent = 'Connected';
      connectBtn.disabled = true;
      setStatus('Connected.');
      await refreshViews();
    } catch (err){
      console.error(err);
      setStatus(friendlyError(err) || 'Failed to connect', false);
    }
  }

  async function switchToMainnet(){
    try {
      await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x1' }] });
      chainId = 1; updateChainUI(); setStatus('Switched to Ethereum Mainnet.');
      await refreshViews();
    } catch (err){ setStatus('Switch rejected or failed.', false); }
  }

  async function mint(){
    if (!signer) return setStatus('Connect your wallet first.', false);
    if (!isOnMainnet()) return setStatus('Please switch to Ethereum Mainnet.', false);

    const qty = Math.min(5, Math.max(1, parseInt(qtyInput.value || '1',10)));
    qtyInput.value = String(qty);
    const q = BigInt(qty);
    const value = priceWei * q;

    try {
      setStatus('Sending transaction…');
      const args = HAS_AMOUNT_ARG ? [q] : [];
      const overrides = priceWei ? { value } : {};

      try { await contract.estimateGas[FUNCTION_NAME](...args, overrides); } catch {}

      const tx = await contract[FUNCTION_NAME](...args, overrides);
      setStatus(`Waiting for confirmation… ${tx.hash.slice(0,10)}…`);
      await tx.wait();
      setStatus('Mint successful!');
      const link = document.createElement('a');
      link.href = `https://etherscan.io/tx/${tx.hash}`; link.target = '_blank'; link.textContent = 'View on Etherscan';
      statusEl.appendChild(document.createTextNode(' '));
      statusEl.appendChild(link);
      await refreshViews();
    } catch (err){
      console.error(err);
      setStatus(friendlyError(err) || 'Transaction failed', false);
    }
  }

  // Minimal ABI (edit to fit your contract)
  const ABI = [
    { "type":"function", "stateMutability":"payable", "name":"mint", "inputs":[{"name":"amount","type":"uint256"}], "outputs":[] },
    { "type":"function", "stateMutability":"payable", "name":"publicMint", "inputs":[{"name":"amount","type":"uint256"}], "outputs":[] },
    { "type":"function", "stateMutability":"view", "name": PRICE_FN, "inputs":[], "outputs":[{"type":"uint256"}] },
    { "type":"function", "stateMutability":"view", "name": TOTAL_SUPPLY_FN, "inputs":[], "outputs":[{"type":"uint256"}] },
    { "type":"function", "stateMutability":"view", "name": MAX_SUPPLY_FN, "inputs":[], "outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"totalMinted","inputs":[],"outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"collectionSize","inputs":[],"outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"currentIndex","inputs":[],"outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"nextTokenId","inputs":[],"outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"MAX_SUPPLY","inputs":[],"outputs":[{"type":"uint256"}] },
    { "type":"function","stateMutability":"view","name":"startTokenId","inputs":[],"outputs":[{"type":"uint256"}] }
  ];

  // UI Hooks
  connectBtn.addEventListener('click', connect);
  switchBtn.addEventListener('click', switchToMainnet);
  mintBtn.addEventListener('click', mint);
  minusBtn.addEventListener('click', () => { qtyInput.value = Math.max(1, (parseInt(qtyInput.value,10)||1) - 1); onQtyChanged(); });
  plusBtn.addEventListener('click',  () => { qtyInput.value = Math.min(5, (parseInt(qtyInput.value,10)||1) + 1); onQtyChanged(); });
  qtyInput.addEventListener('input', onQtyChanged);
  maxBtn.addEventListener('click', () => { qtyInput.value = 5; onQtyChanged(); });
  // Expose a safe global fallback for the Connect button if addEventListener fails to bind
  window._connect = connect;

  // Wallet event listeners
  if (window.ethereum){
    window.ethereum.on?.('accountsChanged', (accs)=>{ account = accs[0]; accountPill.textContent = shortAddr(account||''); updateChainUI(); });
    window.ethereum.on?.('chainChanged', (hex)=>{ chainId = parseInt(hex,16); updateChainUI(); refreshViews(); });
  }

  // Initial labels
  (async() => { try { await ensureProvider(); await refreshViews(); } catch (e) { setStatus('No wallet detected. Install MetaMask (desktop) or open this page in your wallet\'s in-app browser.', false); } })();
})();
</script>
</body>
</html>
